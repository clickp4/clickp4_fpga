//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Sun Jun  4 09:46:06 CST 2017
//
// BVI format method schedule info:
// schedule metadata_enq  CF ( writeServer_enq,
// 			    writeServer_notFull,
// 			    writeClient_first,
// 			    writeClient_deq,
// 			    writeClient_notEmpty,
// 			    set_verbosity,
// 			    read_perf_info );
// schedule metadata_enq  C ( metadata_enq );
//
// schedule metadata_notFull  CF ( metadata_notFull,
// 				writeServer_enq,
// 				writeServer_notFull,
// 				writeClient_first,
// 				writeClient_deq,
// 				writeClient_notEmpty,
// 				set_verbosity,
// 				read_perf_info );
// schedule metadata_notFull  SB ( metadata_enq );
//
// schedule writeServer_enq  CF ( metadata_enq,
// 			       metadata_notFull,
// 			       writeClient_first,
// 			       writeClient_deq,
// 			       writeClient_notEmpty,
// 			       set_verbosity,
// 			       read_perf_info );
// schedule writeServer_enq  C ( writeServer_enq );
//
// schedule writeServer_notFull  CF ( metadata_enq,
// 				   metadata_notFull,
// 				   writeServer_notFull,
// 				   writeClient_first,
// 				   writeClient_deq,
// 				   writeClient_notEmpty,
// 				   set_verbosity,
// 				   read_perf_info );
// schedule writeServer_notFull  SB ( writeServer_enq );
//
// schedule writeClient_first  CF ( metadata_enq,
// 				 metadata_notFull,
// 				 writeServer_enq,
// 				 writeServer_notFull,
// 				 writeClient_first,
// 				 writeClient_notEmpty,
// 				 set_verbosity,
// 				 read_perf_info );
// schedule writeClient_first  SB ( writeClient_deq );
//
// schedule writeClient_deq  CF ( metadata_enq,
// 			       metadata_notFull,
// 			       writeServer_enq,
// 			       writeServer_notFull,
// 			       set_verbosity,
// 			       read_perf_info );
// schedule writeClient_deq  C ( writeClient_deq );
//
// schedule writeClient_notEmpty  CF ( metadata_enq,
// 				    metadata_notFull,
// 				    writeServer_enq,
// 				    writeServer_notFull,
// 				    writeClient_first,
// 				    writeClient_notEmpty,
// 				    set_verbosity,
// 				    read_perf_info );
// schedule writeClient_notEmpty  SB ( writeClient_deq );
//
// schedule set_verbosity  CF ( metadata_enq,
// 			     metadata_notFull,
// 			     writeServer_enq,
// 			     writeServer_notFull,
// 			     writeClient_first,
// 			     writeClient_deq,
// 			     writeClient_notEmpty,
// 			     read_perf_info );
// schedule set_verbosity  SBR ( set_verbosity );
//
// schedule read_perf_info  CF ( metadata_enq,
// 			      metadata_notFull,
// 			      writeServer_enq,
// 			      writeServer_notFull,
// 			      writeClient_first,
// 			      writeClient_deq,
// 			      writeClient_notEmpty,
// 			      set_verbosity,
// 			      read_perf_info );
//
//
// Ports:
// Name                         I/O  size props
// RDY_metadata_enq               O     1 reg
// metadata_notFull               O     1 reg
// RDY_metadata_notFull           O     1 const
// RDY_writeServer_enq            O     1 reg
// writeServer_notFull            O     1 reg
// RDY_writeServer_notFull        O     1 const
// writeClient_first              O   178 reg
// RDY_writeClient_first          O     1 reg
// RDY_writeClient_deq            O     1 reg
// writeClient_notEmpty           O     1 reg
// RDY_writeClient_notEmpty       O     1 const
// RDY_set_verbosity              O     1 const
// read_perf_info                 O    64 const
// RDY_read_perf_info             O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// metadata_enq_v                 I  1773 reg
// writeServer_enq_v              I   178 reg
// set_verbosity_verbosity        I    32 reg
// EN_metadata_enq                I     1
// EN_writeServer_enq             I     1
// EN_writeClient_deq             I     1
// EN_set_verbosity               I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkDeparser(CLK,
		  RST_N,

		  metadata_enq_v,
		  EN_metadata_enq,
		  RDY_metadata_enq,

		  metadata_notFull,
		  RDY_metadata_notFull,

		  writeServer_enq_v,
		  EN_writeServer_enq,
		  RDY_writeServer_enq,

		  writeServer_notFull,
		  RDY_writeServer_notFull,

		  writeClient_first,
		  RDY_writeClient_first,

		  EN_writeClient_deq,
		  RDY_writeClient_deq,

		  writeClient_notEmpty,
		  RDY_writeClient_notEmpty,

		  set_verbosity_verbosity,
		  EN_set_verbosity,
		  RDY_set_verbosity,

		  read_perf_info,
		  RDY_read_perf_info);
  input  CLK;
  input  RST_N;

  // action method metadata_enq
  input  [1772 : 0] metadata_enq_v;
  input  EN_metadata_enq;
  output RDY_metadata_enq;

  // value method metadata_notFull
  output metadata_notFull;
  output RDY_metadata_notFull;

  // action method writeServer_enq
  input  [177 : 0] writeServer_enq_v;
  input  EN_writeServer_enq;
  output RDY_writeServer_enq;

  // value method writeServer_notFull
  output writeServer_notFull;
  output RDY_writeServer_notFull;

  // value method writeClient_first
  output [177 : 0] writeClient_first;
  output RDY_writeClient_first;

  // action method writeClient_deq
  input  EN_writeClient_deq;
  output RDY_writeClient_deq;

  // value method writeClient_notEmpty
  output writeClient_notEmpty;
  output RDY_writeClient_notEmpty;

  // action method set_verbosity
  input  [31 : 0] set_verbosity_verbosity;
  input  EN_set_verbosity;
  output RDY_set_verbosity;

  // value method read_perf_info
  output [63 : 0] read_perf_info;
  output RDY_read_perf_info;

  // signals for module outputs
  wire [177 : 0] writeClient_first;
  wire [63 : 0] read_perf_info;
  wire RDY_metadata_enq,
       RDY_metadata_notFull,
       RDY_read_perf_info,
       RDY_set_verbosity,
       RDY_writeClient_deq,
       RDY_writeClient_first,
       RDY_writeClient_notEmpty,
       RDY_writeServer_enq,
       RDY_writeServer_notFull,
       metadata_notFull,
       writeClient_notEmpty,
       writeServer_notFull;

  // register cf_verbosity
  reg [31 : 0] cf_verbosity;
  wire [31 : 0] cf_verbosity_D_IN;
  wire cf_verbosity_EN;

  // register data_ff_cntr_r
  reg [1 : 0] data_ff_cntr_r;
  wire [1 : 0] data_ff_cntr_r_D_IN;
  wire data_ff_cntr_r_EN;

  // register data_ff_q_0
  reg [128 : 0] data_ff_q_0;
  wire [128 : 0] data_ff_q_0_D_IN;
  wire data_ff_q_0_EN;

  // register data_ff_q_1
  reg [128 : 0] data_ff_q_1;
  wire [128 : 0] data_ff_q_1_D_IN;
  wire data_ff_q_1_EN;

  // register deparse_done
  reg deparse_done;
  wire deparse_done_D_IN, deparse_done_EN;

  // register deparse_state_ff_rv
  reg deparse_state_ff_rv;
  wire deparse_state_ff_rv_D_IN, deparse_state_ff_rv_EN;

  // register deparsing
  reg deparsing;
  wire deparsing_D_IN, deparsing_EN;

  // register eoh_mask
  reg [127 : 0] eoh_mask;
  wire [127 : 0] eoh_mask_D_IN;
  wire eoh_mask_EN;

  // register header_done
  reg header_done;
  wire header_done_D_IN, header_done_EN;

  // register rg_beat
  reg [9 : 0] rg_beat;
  wire [9 : 0] rg_beat_D_IN;
  wire rg_beat_EN;

  // register rg_buffered
  reg [9 : 0] rg_buffered;
  wire [9 : 0] rg_buffered_D_IN;
  wire rg_buffered_EN;

  // register rg_eop
  reg rg_eop;
  wire rg_eop_D_IN, rg_eop_EN;

  // register rg_metadata
  reg [1772 : 0] rg_metadata;
  wire [1772 : 0] rg_metadata_D_IN;
  wire rg_metadata_EN;

  // register rg_processed
  reg [9 : 0] rg_processed;
  wire [9 : 0] rg_processed_D_IN;
  wire rg_processed_EN;

  // register rg_shift_amt
  reg [9 : 0] rg_shift_amt;
  wire [9 : 0] rg_shift_amt_D_IN;
  wire rg_shift_amt_EN;

  // register rg_sop
  reg rg_sop;
  wire rg_sop_D_IN, rg_sop_EN;

  // register rg_stage3
  reg [255 : 0] rg_stage3;
  wire [255 : 0] rg_stage3_D_IN;
  wire rg_stage3_EN;

  // register rg_tmp
  reg [255 : 0] rg_tmp;
  wire [255 : 0] rg_tmp_D_IN;
  wire rg_tmp_EN;

  // ports of submodule data_in_ff
  wire [177 : 0] data_in_ff_D_IN, data_in_ff_D_OUT;
  wire data_in_ff_CLR,
       data_in_ff_DEQ,
       data_in_ff_EMPTY_N,
       data_in_ff_ENQ,
       data_in_ff_FULL_N;

  // ports of submodule data_out_ff
  reg [177 : 0] data_out_ff_D_IN;
  wire [177 : 0] data_out_ff_D_OUT;
  wire data_out_ff_CLR,
       data_out_ff_DEQ,
       data_out_ff_EMPTY_N,
       data_out_ff_ENQ,
       data_out_ff_FULL_N;

  // ports of submodule meta_in_ff
  wire [1772 : 0] meta_in_ff_D_IN, meta_in_ff_D_OUT;
  wire meta_in_ff_CLR,
       meta_in_ff_DEQ,
       meta_in_ff_EMPTY_N,
       meta_in_ff_ENQ,
       meta_in_ff_FULL_N;

  // ports of submodule stage1_ff
  wire [255 : 0] stage1_ff_D_IN;
  wire stage1_ff_CLR, stage1_ff_DEQ, stage1_ff_ENQ;

  // ports of submodule stage2_ff
  wire [2040 : 0] stage2_ff_D_IN, stage2_ff_D_OUT;
  wire stage2_ff_CLR, stage2_ff_DEQ, stage2_ff_EMPTY_N, stage2_ff_ENQ;

  // ports of submodule stage3_ff
  wire [267 : 0] stage3_ff_D_IN, stage3_ff_D_OUT;
  wire stage3_ff_CLR,
       stage3_ff_DEQ,
       stage3_ff_EMPTY_N,
       stage3_ff_ENQ,
       stage3_ff_FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_header_completion,
       WILL_FIRE_RL_rl_deparse_payload,
       WILL_FIRE_RL_rl_deparse_start,
       WILL_FIRE_RL_rl_header_completion,
       WILL_FIRE_RL_rl_stage2_apply_metadata,
       WILL_FIRE_RL_rl_stage3_begin,
       WILL_FIRE_RL_rl_stage3_cont,
       WILL_FIRE_RL_rl_stage3_end;

  // inputs to muxes for submodule ports
  wire [255 : 0] MUX_rg_stage3_write_1__VAL_1;
  wire [177 : 0] MUX_data_out_ff_enq_1__VAL_2,
		 MUX_data_out_ff_enq_1__VAL_3,
		 MUX_data_out_ff_enq_1__VAL_4;
  wire [9 : 0] MUX_rg_beat_write_1__VAL_1, MUX_rg_processed_write_1__VAL_2;
  wire MUX_rg_processed_write_1__SEL_1;

  // remaining internal signals
  reg [63 : 0] v___1__h8140,
	       v___1__h8341,
	       v__h8373,
	       v__h8614,
	       v__h8674,
	       v__h8910;
  wire [15 : 0] mask_out__h8725, mask_out__h9141, x__h8964, x__h9218;
  wire [9 : 0] n_beat__h8287;
  wire _dor1rg_sop_EN_write;

  // action method metadata_enq
  assign RDY_metadata_enq = meta_in_ff_FULL_N ;

  // value method metadata_notFull
  assign metadata_notFull = meta_in_ff_FULL_N ;
  assign RDY_metadata_notFull = 1'd1 ;

  // action method writeServer_enq
  assign RDY_writeServer_enq = data_in_ff_FULL_N ;

  // value method writeServer_notFull
  assign writeServer_notFull = data_in_ff_FULL_N ;
  assign RDY_writeServer_notFull = 1'd1 ;

  // value method writeClient_first
  assign writeClient_first = data_out_ff_D_OUT ;
  assign RDY_writeClient_first = data_out_ff_EMPTY_N ;

  // action method writeClient_deq
  assign RDY_writeClient_deq = data_out_ff_EMPTY_N ;

  // value method writeClient_notEmpty
  assign writeClient_notEmpty = data_out_ff_EMPTY_N ;
  assign RDY_writeClient_notEmpty = 1'd1 ;

  // action method set_verbosity
  assign RDY_set_verbosity = 1'd1 ;

  // value method read_perf_info
  assign read_perf_info = 64'hAAAAAAAAAAAAAAAA ;
  assign RDY_read_perf_info = 1'd1 ;

  // submodule data_in_ff
  FIFO2 #(.width(32'd178), .guarded(32'd1)) data_in_ff(.RST(RST_N),
						       .CLK(CLK),
						       .D_IN(data_in_ff_D_IN),
						       .ENQ(data_in_ff_ENQ),
						       .DEQ(data_in_ff_DEQ),
						       .CLR(data_in_ff_CLR),
						       .D_OUT(data_in_ff_D_OUT),
						       .FULL_N(data_in_ff_FULL_N),
						       .EMPTY_N(data_in_ff_EMPTY_N));

  // submodule data_out_ff
  FIFO2 #(.width(32'd178), .guarded(32'd1)) data_out_ff(.RST(RST_N),
							.CLK(CLK),
							.D_IN(data_out_ff_D_IN),
							.ENQ(data_out_ff_ENQ),
							.DEQ(data_out_ff_DEQ),
							.CLR(data_out_ff_CLR),
							.D_OUT(data_out_ff_D_OUT),
							.FULL_N(data_out_ff_FULL_N),
							.EMPTY_N(data_out_ff_EMPTY_N));

  // submodule meta_in_ff
  SizedFIFO #(.p1width(32'd1773),
	      .p2depth(32'd16),
	      .p3cntr_width(32'd4),
	      .guarded(32'd1)) meta_in_ff(.RST(RST_N),
					  .CLK(CLK),
					  .D_IN(meta_in_ff_D_IN),
					  .ENQ(meta_in_ff_ENQ),
					  .DEQ(meta_in_ff_DEQ),
					  .CLR(meta_in_ff_CLR),
					  .D_OUT(meta_in_ff_D_OUT),
					  .FULL_N(meta_in_ff_FULL_N),
					  .EMPTY_N(meta_in_ff_EMPTY_N));

  // submodule stage1_ff
  FIFO2 #(.width(32'd256), .guarded(32'd1)) stage1_ff(.RST(RST_N),
						      .CLK(CLK),
						      .D_IN(stage1_ff_D_IN),
						      .ENQ(stage1_ff_ENQ),
						      .DEQ(stage1_ff_DEQ),
						      .CLR(stage1_ff_CLR),
						      .D_OUT(),
						      .FULL_N(),
						      .EMPTY_N());

  // submodule stage2_ff
  FIFO2 #(.width(32'd2041), .guarded(32'd1)) stage2_ff(.RST(RST_N),
						       .CLK(CLK),
						       .D_IN(stage2_ff_D_IN),
						       .ENQ(stage2_ff_ENQ),
						       .DEQ(stage2_ff_DEQ),
						       .CLR(stage2_ff_CLR),
						       .D_OUT(stage2_ff_D_OUT),
						       .FULL_N(),
						       .EMPTY_N(stage2_ff_EMPTY_N));

  // submodule stage3_ff
  FIFO2 #(.width(32'd268), .guarded(32'd1)) stage3_ff(.RST(RST_N),
						      .CLK(CLK),
						      .D_IN(stage3_ff_D_IN),
						      .ENQ(stage3_ff_ENQ),
						      .DEQ(stage3_ff_DEQ),
						      .CLR(stage3_ff_CLR),
						      .D_OUT(stage3_ff_D_OUT),
						      .FULL_N(stage3_ff_FULL_N),
						      .EMPTY_N(stage3_ff_EMPTY_N));

  // rule RL_rl_deparse_start
  assign WILL_FIRE_RL_rl_deparse_start =
	     meta_in_ff_EMPTY_N && data_in_ff_EMPTY_N && deparse_done &&
	     data_in_ff_D_OUT[1] ;

  // rule RL_rl_stage2_apply_metadata
  assign WILL_FIRE_RL_rl_stage2_apply_metadata =
	     stage2_ff_EMPTY_N && stage3_ff_FULL_N ;

  // rule RL_rl_stage3_begin
  assign WILL_FIRE_RL_rl_stage3_begin = stage3_ff_EMPTY_N && !deparsing ;

  // rule RL_rl_deparse_payload
  assign WILL_FIRE_RL_rl_deparse_payload =
	     data_in_ff_EMPTY_N && data_out_ff_FULL_N && deparse_done &&
	     !WILL_FIRE_RL_rl_deparse_start ;

  // rule RL_rl_stage3_cont
  assign WILL_FIRE_RL_rl_stage3_cont =
	     data_out_ff_FULL_N && deparsing && rg_beat != 10'd0 &&
	     !WILL_FIRE_RL_rl_deparse_payload ;

  // rule RL_rl_stage3_end
  assign WILL_FIRE_RL_rl_stage3_end =
	     data_out_ff_FULL_N && stage3_ff_EMPTY_N && deparsing &&
	     rg_beat == 10'd0 &&
	     !WILL_FIRE_RL_rl_deparse_payload ;

  // rule RL_rl_header_completion
  assign CAN_FIRE_RL_rl_header_completion =
	     data_out_ff_FULL_N && !deparse_done && !deparsing &&
	     header_done &&
	     rg_processed == 10'd0 ;
  assign WILL_FIRE_RL_rl_header_completion =
	     CAN_FIRE_RL_rl_header_completion &&
	     !WILL_FIRE_RL_rl_stage3_begin ;

  // inputs to muxes for submodule ports
  assign MUX_rg_processed_write_1__SEL_1 =
	     WILL_FIRE_RL_rl_deparse_payload && data_in_ff_D_OUT[0] ;
  assign MUX_data_out_ff_enq_1__VAL_2 =
	     { 32'd0, rg_stage3[127:0], 16'hFFFF, rg_sop, 1'd0 } ;
  assign MUX_data_out_ff_enq_1__VAL_3 =
	     { 32'd0, rg_stage3[127:0], mask_out__h8725, rg_sop, 1'd0 } ;
  assign MUX_data_out_ff_enq_1__VAL_4 =
	     { 32'd0, rg_tmp[127:0], mask_out__h9141, 2'd0 } ;
  assign MUX_rg_beat_write_1__VAL_1 = rg_beat - 10'd1 ;
  assign MUX_rg_processed_write_1__VAL_2 = rg_processed - 10'd128 ;
  assign MUX_rg_stage3_write_1__VAL_1 = { 128'd0, rg_stage3[255:128] } ;

  // register cf_verbosity
  assign cf_verbosity_D_IN = set_verbosity_verbosity ;
  assign cf_verbosity_EN = EN_set_verbosity ;

  // register data_ff_cntr_r
  assign data_ff_cntr_r_D_IN = 2'b10 /* unspecified value */  ;
  assign data_ff_cntr_r_EN = 1'b0 ;

  // register data_ff_q_0
  assign data_ff_q_0_D_IN =
	     129'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */  ;
  assign data_ff_q_0_EN = 1'b0 ;

  // register data_ff_q_1
  assign data_ff_q_1_D_IN =
	     129'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */  ;
  assign data_ff_q_1_EN = 1'b0 ;

  // register deparse_done
  assign deparse_done_D_IN = !WILL_FIRE_RL_rl_deparse_start ;
  assign deparse_done_EN =
	     WILL_FIRE_RL_rl_deparse_start ||
	     WILL_FIRE_RL_rl_header_completion ;

  // register deparse_state_ff_rv
  assign deparse_state_ff_rv_D_IN = deparse_state_ff_rv ;
  assign deparse_state_ff_rv_EN = 1'b1 ;

  // register deparsing
  assign deparsing_D_IN = !WILL_FIRE_RL_rl_stage3_end ;
  assign deparsing_EN =
	     WILL_FIRE_RL_rl_stage3_end || WILL_FIRE_RL_rl_stage3_begin ;

  // register eoh_mask
  assign eoh_mask_D_IN = 128'h0 ;
  assign eoh_mask_EN = 1'b0 ;

  // register header_done
  assign header_done_D_IN = !WILL_FIRE_RL_rl_header_completion ;
  assign header_done_EN =
	     WILL_FIRE_RL_rl_header_completion ||
	     WILL_FIRE_RL_rl_deparse_start ;

  // register rg_beat
  assign rg_beat_D_IN =
	     WILL_FIRE_RL_rl_stage3_cont ?
	       MUX_rg_beat_write_1__VAL_1 :
	       n_beat__h8287 ;
  assign rg_beat_EN =
	     WILL_FIRE_RL_rl_stage3_cont || WILL_FIRE_RL_rl_stage3_begin ;

  // register rg_buffered
  assign rg_buffered_D_IN = 10'd0 ;
  assign rg_buffered_EN = MUX_rg_processed_write_1__SEL_1 ;

  // register rg_eop
  assign rg_eop_D_IN = 1'b0 ;
  assign rg_eop_EN = 1'b0 ;

  // register rg_metadata
  assign rg_metadata_D_IN = meta_in_ff_D_OUT ;
  assign rg_metadata_EN = WILL_FIRE_RL_rl_deparse_start ;

  // register rg_processed
  assign rg_processed_D_IN =
	     WILL_FIRE_RL_rl_stage3_cont ?
	       MUX_rg_processed_write_1__VAL_2 :
	       10'd0 ;
  assign rg_processed_EN =
	     WILL_FIRE_RL_rl_deparse_payload && data_in_ff_D_OUT[0] ||
	     WILL_FIRE_RL_rl_stage3_cont ||
	     WILL_FIRE_RL_rl_stage3_end ;

  // register rg_shift_amt
  assign rg_shift_amt_D_IN = 10'd0 ;
  assign rg_shift_amt_EN =
	     WILL_FIRE_RL_rl_deparse_payload && data_in_ff_D_OUT[0] ||
	     WILL_FIRE_RL_rl_header_completion ;

  // register rg_sop
  assign rg_sop_D_IN = 1'd0 ;
  assign rg_sop_EN = _dor1rg_sop_EN_write && rg_sop ;

  // register rg_stage3
  assign rg_stage3_D_IN =
	     WILL_FIRE_RL_rl_stage3_cont ?
	       MUX_rg_stage3_write_1__VAL_1 :
	       stage3_ff_D_OUT[265:10] ;
  assign rg_stage3_EN =
	     WILL_FIRE_RL_rl_stage3_cont || WILL_FIRE_RL_rl_stage3_begin ;

  // register rg_tmp
  assign rg_tmp_D_IN = 256'd0 ;
  assign rg_tmp_EN = MUX_rg_processed_write_1__SEL_1 ;

  // submodule data_in_ff
  assign data_in_ff_D_IN = writeServer_enq_v ;
  assign data_in_ff_ENQ = EN_writeServer_enq ;
  assign data_in_ff_DEQ = WILL_FIRE_RL_rl_deparse_payload ;
  assign data_in_ff_CLR = 1'b0 ;

  // submodule data_out_ff
  always@(WILL_FIRE_RL_rl_deparse_payload or
	  data_in_ff_D_OUT or
	  WILL_FIRE_RL_rl_stage3_cont or
	  MUX_data_out_ff_enq_1__VAL_2 or
	  WILL_FIRE_RL_rl_stage3_end or
	  MUX_data_out_ff_enq_1__VAL_3 or
	  WILL_FIRE_RL_rl_header_completion or MUX_data_out_ff_enq_1__VAL_4)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_rl_deparse_payload: data_out_ff_D_IN = data_in_ff_D_OUT;
      WILL_FIRE_RL_rl_stage3_cont:
	  data_out_ff_D_IN = MUX_data_out_ff_enq_1__VAL_2;
      WILL_FIRE_RL_rl_stage3_end:
	  data_out_ff_D_IN = MUX_data_out_ff_enq_1__VAL_3;
      WILL_FIRE_RL_rl_header_completion:
	  data_out_ff_D_IN = MUX_data_out_ff_enq_1__VAL_4;
      default: data_out_ff_D_IN =
		   178'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign data_out_ff_ENQ =
	     WILL_FIRE_RL_rl_deparse_payload || WILL_FIRE_RL_rl_stage3_cont ||
	     WILL_FIRE_RL_rl_stage3_end ||
	     WILL_FIRE_RL_rl_header_completion ;
  assign data_out_ff_DEQ = EN_writeClient_deq ;
  assign data_out_ff_CLR = 1'b0 ;

  // submodule meta_in_ff
  assign meta_in_ff_D_IN = metadata_enq_v ;
  assign meta_in_ff_ENQ = EN_metadata_enq ;
  assign meta_in_ff_DEQ = WILL_FIRE_RL_rl_deparse_start ;
  assign meta_in_ff_CLR = 1'b0 ;

  // submodule stage1_ff
  assign stage1_ff_D_IN = 256'h0 ;
  assign stage1_ff_ENQ = 1'b0 ;
  assign stage1_ff_DEQ = 1'b0 ;
  assign stage1_ff_CLR = 1'b0 ;

  // submodule stage2_ff
  assign stage2_ff_D_IN = 2041'h0 ;
  assign stage2_ff_ENQ = 1'b0 ;
  assign stage2_ff_DEQ = WILL_FIRE_RL_rl_stage2_apply_metadata ;
  assign stage2_ff_CLR = 1'b0 ;

  // submodule stage3_ff
  assign stage3_ff_D_IN = stage2_ff_D_OUT[2040:1773] ;
  assign stage3_ff_ENQ = WILL_FIRE_RL_rl_stage2_apply_metadata ;
  assign stage3_ff_DEQ = WILL_FIRE_RL_rl_stage3_end ;
  assign stage3_ff_CLR = 1'b0 ;

  // remaining internal signals
  assign _dor1rg_sop_EN_write =
	     WILL_FIRE_RL_rl_stage3_end || WILL_FIRE_RL_rl_stage3_cont ;
  assign mask_out__h8725 = ~x__h8964 ;
  assign mask_out__h9141 = ~x__h9218 ;
  assign n_beat__h8287 = { 7'd0, stage3_ff_D_OUT[9:7] } ;
  assign x__h8964 = 16'd65535 << rg_processed[7:3] ;
  assign x__h9218 = 16'd65535 << rg_shift_amt[7:3] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        data_ff_cntr_r <= `BSV_ASSIGNMENT_DELAY 2'd0;
	data_ff_q_0 <= `BSV_ASSIGNMENT_DELAY
	    129'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
	data_ff_q_1 <= `BSV_ASSIGNMENT_DELAY
	    129'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
	deparse_done <= `BSV_ASSIGNMENT_DELAY 1'd1;
	deparse_state_ff_rv <= `BSV_ASSIGNMENT_DELAY 1'd0;
	deparsing <= `BSV_ASSIGNMENT_DELAY 1'd0;
	eoh_mask <= `BSV_ASSIGNMENT_DELAY 128'd0;
	header_done <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_beat <= `BSV_ASSIGNMENT_DELAY 10'd0;
	rg_buffered <= `BSV_ASSIGNMENT_DELAY 10'd0;
	rg_eop <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_metadata <= `BSV_ASSIGNMENT_DELAY
	    1773'h055555555555555555555555555554555555555555555555555555555555555555555545555555555555555555555555555555555555555555555555555555555555555555555555555555545555555555555555555555555555555555555555455555555555555554552AAAAAAA955555554AAAAAAAAAAAAAAAAAAAAAAAAAAAA555555552AAAAAAAAAAAAAAA95555555555555554AAAAAAAAAAAAAAAAAAAAAAAAAA55555555154AAAAAAAAAAAAAAAA2A8AA2A955555554AAAAAAAA15554AAAAAAAA55555555155552AAAAAAA8AAAA9555555555554AAAAAAAA55550AAAA;
	rg_processed <= `BSV_ASSIGNMENT_DELAY 10'd0;
	rg_shift_amt <= `BSV_ASSIGNMENT_DELAY 10'd0;
	rg_sop <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_stage3 <= `BSV_ASSIGNMENT_DELAY 256'd0;
	rg_tmp <= `BSV_ASSIGNMENT_DELAY 256'd0;
      end
    else
      begin
        if (data_ff_cntr_r_EN)
	  data_ff_cntr_r <= `BSV_ASSIGNMENT_DELAY data_ff_cntr_r_D_IN;
	if (data_ff_q_0_EN)
	  data_ff_q_0 <= `BSV_ASSIGNMENT_DELAY data_ff_q_0_D_IN;
	if (data_ff_q_1_EN)
	  data_ff_q_1 <= `BSV_ASSIGNMENT_DELAY data_ff_q_1_D_IN;
	if (deparse_done_EN)
	  deparse_done <= `BSV_ASSIGNMENT_DELAY deparse_done_D_IN;
	if (deparse_state_ff_rv_EN)
	  deparse_state_ff_rv <= `BSV_ASSIGNMENT_DELAY
	      deparse_state_ff_rv_D_IN;
	if (deparsing_EN) deparsing <= `BSV_ASSIGNMENT_DELAY deparsing_D_IN;
	if (eoh_mask_EN) eoh_mask <= `BSV_ASSIGNMENT_DELAY eoh_mask_D_IN;
	if (header_done_EN)
	  header_done <= `BSV_ASSIGNMENT_DELAY header_done_D_IN;
	if (rg_beat_EN) rg_beat <= `BSV_ASSIGNMENT_DELAY rg_beat_D_IN;
	if (rg_buffered_EN)
	  rg_buffered <= `BSV_ASSIGNMENT_DELAY rg_buffered_D_IN;
	if (rg_eop_EN) rg_eop <= `BSV_ASSIGNMENT_DELAY rg_eop_D_IN;
	if (rg_metadata_EN)
	  rg_metadata <= `BSV_ASSIGNMENT_DELAY rg_metadata_D_IN;
	if (rg_processed_EN)
	  rg_processed <= `BSV_ASSIGNMENT_DELAY rg_processed_D_IN;
	if (rg_shift_amt_EN)
	  rg_shift_amt <= `BSV_ASSIGNMENT_DELAY rg_shift_amt_D_IN;
	if (rg_sop_EN) rg_sop <= `BSV_ASSIGNMENT_DELAY rg_sop_D_IN;
	if (rg_stage3_EN) rg_stage3 <= `BSV_ASSIGNMENT_DELAY rg_stage3_D_IN;
	if (rg_tmp_EN) rg_tmp <= `BSV_ASSIGNMENT_DELAY rg_tmp_D_IN;
      end
    if (cf_verbosity_EN)
      cf_verbosity <= `BSV_ASSIGNMENT_DELAY cf_verbosity_D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cf_verbosity = 32'hAAAAAAAA;
    data_ff_cntr_r = 2'h2;
    data_ff_q_0 = 129'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    data_ff_q_1 = 129'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    deparse_done = 1'h0;
    deparse_state_ff_rv = 1'h0;
    deparsing = 1'h0;
    eoh_mask = 128'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    header_done = 1'h0;
    rg_beat = 10'h2AA;
    rg_buffered = 10'h2AA;
    rg_eop = 1'h0;
    rg_metadata =
	1773'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    rg_processed = 10'h2AA;
    rg_shift_amt = 10'h2AA;
    rg_sop = 1'h0;
    rg_stage3 =
	256'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    rg_tmp =
	256'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage2_apply_metadata)
	begin
	  v___1__h8140 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage2_apply_metadata)
	$display("(%0d) stage2 %h len=%d",
		 v___1__h8140,
		 stage2_ff_D_OUT[2038:1783],
		 stage2_ff_D_OUT[1782:1773]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage3_begin)
	begin
	  v___1__h8341 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage3_begin)
	$display("(%0d) stage3 %h beat=%d",
		 v___1__h8341,
		 stage3_ff_D_OUT[265:10],
		 n_beat__h8287);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage3_begin)
	begin
	  v__h8373 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage3_begin)
	$display("(%0d) stage3 begin rg_shift_amt next = %d",
		 v__h8373,
		 rg_shift_amt);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage3_cont)
	begin
	  v__h8614 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage3_cont) $write("(%0d) stage3 cont ", v__h8614);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage3_cont)
	$write(" data=0x%x", rg_stage3[127:0], " mask=0x%x", 16'hFFFF);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage3_cont) $write(" user=0x%x", 32'd0);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage3_cont) $write(" sop=%d", rg_sop);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage3_cont) $write(" eop=%d", 1'd0);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage3_cont) $write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage3_cont)
	begin
	  v__h8674 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage3_cont)
	$display("(%0d) stage3 cont rg_shift_amt next = %d",
		 v__h8674,
		 rg_shift_amt);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage3_end)
	begin
	  v__h8910 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage3_end)
	$display("(%0d) stage3 end %h rg_processed %d",
		 v__h8910,
		 rg_stage3,
		 rg_processed);
  end
  // synopsys translate_on
endmodule  // mkDeparser

