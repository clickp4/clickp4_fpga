//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Sun Jun  4 10:30:22 CST 2017
//
// BVI format method schedule info:
// schedule setPeriod  CF ( ifc_out );
// schedule setPeriod  SBR ( setPeriod );
//
// schedule ifc_out  CF ( setPeriod, ifc_out );
//
//
// Ports:
// Name                         I/O  size props
// out                            O     1
// invert                         I     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// setPeriod_lo_lvl               I     3 reg
// setPeriod_lo_time              I    16 reg
// setPeriod_hi_lvl               I     3 reg
// setPeriod_hi_time              I    16 reg
// EN_setPeriod                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkLedController(invert,
		       CLK,
		       RST_N,

		       setPeriod_lo_lvl,
		       setPeriod_lo_time,
		       setPeriod_hi_lvl,
		       setPeriod_hi_time,
		       EN_setPeriod,

		       out);
  input  invert;
  input  CLK;
  input  RST_N;

  // action method setPeriod
  input  [2 : 0] setPeriod_lo_lvl;
  input  [15 : 0] setPeriod_lo_time;
  input  [2 : 0] setPeriod_hi_lvl;
  input  [15 : 0] setPeriod_hi_time;
  input  EN_setPeriod;

  // value method ifc_out
  output out;

  // signals for module outputs
  wire out;

  // inlined wires
  wire [2 : 0] new_level_wget;

  // register _unnamed_
  reg _unnamed_;
  wire _unnamed__D_IN, _unnamed__EN;

  // register countdown
  reg [15 : 0] countdown;
  wire [15 : 0] countdown_D_IN;
  wire countdown_EN;

  // register counter
  reg [15 : 0] counter;
  wire [15 : 0] counter_D_IN;
  wire counter_EN;

  // register current_level
  reg [2 : 0] current_level;
  wire [2 : 0] current_level_D_IN;
  wire current_level_EN;

  // register hi
  reg [2 : 0] hi;
  wire [2 : 0] hi_D_IN;
  wire hi_EN;

  // register hi_for
  reg [15 : 0] hi_for;
  wire [15 : 0] hi_for_D_IN;
  wire hi_for_EN;

  // register lo
  reg [2 : 0] lo;
  wire [2 : 0] lo_D_IN;
  wire lo_EN;

  // register lo_for
  reg [15 : 0] lo_for;
  wire [15 : 0] lo_for_D_IN;
  wire lo_for_EN;

  // register pattern
  reg [15 : 0] pattern;
  wire [15 : 0] pattern_D_IN;
  wire pattern_EN;

  // register target_level
  reg [2 : 0] target_level;
  wire [2 : 0] target_level_D_IN;
  wire target_level_EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_new_pattern;

  // inputs to muxes for submodule ports
  reg [15 : 0] MUX_pattern_write_1__VAL_1;
  wire [15 : 0] MUX_pattern_write_1__VAL_2;

  // remaining internal signals
  reg [2 : 0] CASE_current_level_MINUS_target_level_0_0_1_1__ETC__q1,
	      CASE_target_level_MINUS_current_level_0_0_1_1__ETC__q2;
  wire target_level_7_EQ_lo_7___d68;

  // value method ifc_out
  assign out = _unnamed_ ;

  // rule RL_new_pattern
  assign WILL_FIRE_RL_new_pattern =
	     counter == 16'd0 && current_level != target_level ;

  // inputs to muxes for submodule ports
  always@(new_level_wget)
  begin
    case (new_level_wget)
      3'd0: MUX_pattern_write_1__VAL_1 = 16'b0;
      3'd1: MUX_pattern_write_1__VAL_1 = 16'b0000000100000001;
      3'd2: MUX_pattern_write_1__VAL_1 = 16'b0001000100010001;
      3'd3: MUX_pattern_write_1__VAL_1 = 16'b0101010101010101;
      3'd4: MUX_pattern_write_1__VAL_1 = 16'b0101101101101101;
      3'd5: MUX_pattern_write_1__VAL_1 = 16'b1101010110111011;
      3'd6: MUX_pattern_write_1__VAL_1 = 16'b1111011110111110;
      3'd7: MUX_pattern_write_1__VAL_1 = 16'b1111111111111111;
    endcase
  end
  assign MUX_pattern_write_1__VAL_2 = { pattern[0], pattern[15:1] } ;

  // inlined wires
  assign new_level_wget =
	     (target_level <= current_level) ?
	       current_level -
	       CASE_current_level_MINUS_target_level_0_0_1_1__ETC__q1 :
	       current_level +
	       CASE_target_level_MINUS_current_level_0_0_1_1__ETC__q2 ;

  // register _unnamed_
  assign _unnamed__D_IN = invert ? ~pattern[0] : pattern[0] ;
  assign _unnamed__EN = 1'd1 ;

  // register countdown
  assign countdown_D_IN =
	     (countdown == 16'd0) ?
	       (target_level_7_EQ_lo_7___d68 ? hi_for : lo_for) :
	       countdown - 16'd1 ;
  assign countdown_EN = counter == 16'd0 ;

  // register counter
  assign counter_D_IN = counter + 16'd1 ;
  assign counter_EN = 1'd1 ;

  // register current_level
  assign current_level_D_IN = new_level_wget ;
  assign current_level_EN = WILL_FIRE_RL_new_pattern ;

  // register hi
  assign hi_D_IN = setPeriod_hi_lvl ;
  assign hi_EN = EN_setPeriod ;

  // register hi_for
  assign hi_for_D_IN = setPeriod_hi_time ;
  assign hi_for_EN = EN_setPeriod ;

  // register lo
  assign lo_D_IN = setPeriod_lo_lvl ;
  assign lo_EN = EN_setPeriod ;

  // register lo_for
  assign lo_for_D_IN = setPeriod_lo_time ;
  assign lo_for_EN = EN_setPeriod ;

  // register pattern
  assign pattern_D_IN =
	     WILL_FIRE_RL_new_pattern ?
	       MUX_pattern_write_1__VAL_1 :
	       MUX_pattern_write_1__VAL_2 ;
  assign pattern_EN = 1'b1 ;

  // register target_level
  assign target_level_D_IN = target_level_7_EQ_lo_7___d68 ? hi : lo ;
  assign target_level_EN = counter == 16'd0 && countdown == 16'd0 ;

  // remaining internal signals
  assign target_level_7_EQ_lo_7___d68 = target_level == lo ;
  always@(current_level or target_level)
  begin
    case (current_level - target_level)
      3'd0: CASE_current_level_MINUS_target_level_0_0_1_1__ETC__q1 = 3'd0;
      3'd1, 3'd2, 3'd3:
	  CASE_current_level_MINUS_target_level_0_0_1_1__ETC__q1 = 3'd1;
      3'd4, 3'd5:
	  CASE_current_level_MINUS_target_level_0_0_1_1__ETC__q1 = 3'd2;
      3'd6, 3'd7:
	  CASE_current_level_MINUS_target_level_0_0_1_1__ETC__q1 = 3'd3;
    endcase
  end
  always@(target_level or current_level)
  begin
    case (target_level - current_level)
      3'd0: CASE_target_level_MINUS_current_level_0_0_1_1__ETC__q2 = 3'd0;
      3'd1, 3'd2, 3'd3:
	  CASE_target_level_MINUS_current_level_0_0_1_1__ETC__q2 = 3'd1;
      3'd4, 3'd5:
	  CASE_target_level_MINUS_current_level_0_0_1_1__ETC__q2 = 3'd2;
      3'd6, 3'd7:
	  CASE_target_level_MINUS_current_level_0_0_1_1__ETC__q2 = 3'd3;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        _unnamed_ <= `BSV_ASSIGNMENT_DELAY 1'd0;
	countdown <= `BSV_ASSIGNMENT_DELAY 16'd0;
	counter <= `BSV_ASSIGNMENT_DELAY 16'd0;
	current_level <= `BSV_ASSIGNMENT_DELAY 3'd0;
	hi <= `BSV_ASSIGNMENT_DELAY 3'd0;
	hi_for <= `BSV_ASSIGNMENT_DELAY 16'd500;
	lo <= `BSV_ASSIGNMENT_DELAY 3'd0;
	lo_for <= `BSV_ASSIGNMENT_DELAY 16'd500;
	pattern <= `BSV_ASSIGNMENT_DELAY 16'd0;
	target_level <= `BSV_ASSIGNMENT_DELAY 3'd0;
      end
    else
      begin
        if (_unnamed__EN) _unnamed_ <= `BSV_ASSIGNMENT_DELAY _unnamed__D_IN;
	if (countdown_EN) countdown <= `BSV_ASSIGNMENT_DELAY countdown_D_IN;
	if (counter_EN) counter <= `BSV_ASSIGNMENT_DELAY counter_D_IN;
	if (current_level_EN)
	  current_level <= `BSV_ASSIGNMENT_DELAY current_level_D_IN;
	if (hi_EN) hi <= `BSV_ASSIGNMENT_DELAY hi_D_IN;
	if (hi_for_EN) hi_for <= `BSV_ASSIGNMENT_DELAY hi_for_D_IN;
	if (lo_EN) lo <= `BSV_ASSIGNMENT_DELAY lo_D_IN;
	if (lo_for_EN) lo_for <= `BSV_ASSIGNMENT_DELAY lo_for_D_IN;
	if (pattern_EN) pattern <= `BSV_ASSIGNMENT_DELAY pattern_D_IN;
	if (target_level_EN)
	  target_level <= `BSV_ASSIGNMENT_DELAY target_level_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    _unnamed_ = 1'h0;
    countdown = 16'hAAAA;
    counter = 16'hAAAA;
    current_level = 3'h2;
    hi = 3'h2;
    hi_for = 16'hAAAA;
    lo = 3'h2;
    lo_for = 16'hAAAA;
    pattern = 16'hAAAA;
    target_level = 3'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkLedController

